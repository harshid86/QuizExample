{% extends "_base.twig" %}
{% if isHost %}
{% set back = '/index.php/host' %}
{% else %}
{% set back = '/index.php' %}
{% endif %}
{% block content %}
                <div ng-controller="myQuizCtrl" ng-switch="screen.mode">

                    <div ng-cloak ng-switch-when="hostplayer" class="text-center">

                        <h2>Welcome Host</h2>
                        
                    </div>

                    <div ng-cloak ng-switch-when="welcometeam" class="text-center">
                        <h2>Welcome back, <span ng-bind="team.Name" />!</h2>

                        <button class="btn btn-default btn-lg"  ng-click="screen.showChooseTeam()"><span class="glyphicon glyphicon-user"></span> Choose Different Team</button>
                        &nbsp;
                        <button class="btn btn-success btn-lg"  ng-click="startGame()">Start Game  <span class="glyphicon glyphicon-chevron-right"></span></button>
                    </div>

                    <div ng-cloak ng-switch-when="newteam">


                        <h4>Choose a Team</h4>
                        <form ng-submit="setTeam()" class="form-horizontal">
                            <div class="form-group">
                                  <label class="col-sm-2 control-label">Select your Team:</label>
                                  <div class="col-sm-10">
                                    <select class="form-control" ng-model="team">
                                        <option ng-repeat="t in teams.list" value="[[ t ]]" ng-bind="t.Name"></option>
                                    </select>
                                </div>
                            </div>
                            <div class="form-group">
                                <div class="col-sm-offset-2 col-sm-10">
                                    <button class="btn btn-success" type="submit">Start Game</button>
                                </div>
                            </div>
                        </form>

                    </div>

                    <div ng-cloak ng-switch-when="newround">
                        <div class="round-cell">
                        	<h1 class="splash-title" ng-bind="rounds.current.data.Name"></h1>
                    	</div>

                        <button ng-show="screen.isHostController()" class="btn btn-default btn-lg" ng-click="hostControls.startRoundButton()" type="submit">Start Round</button>
                    </div>

                    <div ng-cloak ng-switch-when="newquestionsplash">

                        <div class="question-cell">
                        	<h1 class="splash-title animated-lsi lightSpeedIn" ng-bind="questions.current.data.QuestionText"></h1>
                    	</div>

                        <button ng-show="screen.isHostController()" class="btn btn-default btn-lg" ng-click="hostControls.startQuestionButton()" type="submit">Start Question</button>

                        <div ng-hide="screen.isHostController()" class="row">
                            <div class="col-xs-1 animate-repeat" ng-repeat="option in options.list">
                                <img class="option-image image-responsive" ng-src="/img/options/[[option.OptionImage]]" />
                            </div>
                        </div>
                    </div>

                    <div ng-cloak ng-switch-when="newquestion">
                        <div>
                            <counter time="[[countdown]]" />
                        </div>

                        <div class="question-cell">
                        	<h1 class="question-text" ng-bind="questions.current.data.QuestionText"></h1>
                    	</div>

                        <div ng-hide="screen.isHostController()" class="row">
                            <div class="col-xs-1" ng-repeat="option in options.list">
                                <div class="option-item animate-repeat">
                                    <img class="option-image image-responsive " ng-src="/img/options/[[option.OptionImage]]" ng-click="makeChoice(option)" />
                                </div>
                            </div>
                        </div>
                    </div>

                    <div ng-cloak ng-switch-when="endgame" class="text-center">

                        <h2>Game Finished</h2>
                        
                    </div>

                </div>
{% endblock %}

{% block script_include %}
<script src="/js/vendor/jquery.piechartcountdown.min.js"></script>
{% endblock %}

{% block ajs_include %}
<script src="/js/directives/counter.js"></script>
<script src="/js/services/counter.js"></script>
<script src="/js/services/httpPost.js"></script>
<script src="/js/services/settings.js"></script>
<script src="/js/services/teams.js"></script>
<script src="/js/services/rounds.js"></script>
<script src="/js/services/questions.js"></script>
<script src="/js/services/options.js"></script>
{% endblock %}

{% block script %}

app.controller("myQuizCtrl", function($scope, $http, $timeout, $sessionStorage, $log, $q, Counter, httpPost, Settings, Teams, Rounds, Questions, Options) {

    var pollingInterval = 500;

    $scope.isHost = {{ isHost }};
    $scope.showControls = {{ showControls }};

    $scope.countdown = 0;

    $scope.storage = $sessionStorage;

    $scope.logInfo = function(logText) {
        roundId = ($scope.rounds.current.data === undefined || $scope.rounds.current.data.id === undefined)
            ? '-'
            : $scope.rounds.current.data.id;

        questionId = ($scope.questions.current.data === undefined || $scope.questions.current.data.id === undefined)
            ? '-'
            : $scope.questions.current.data.id;

        return $log.info('[Round: ' + roundId + '][Question: ' + questionId + '] ' + logText);
    }

    $scope.screen = {
        mode: 'default',

        isPlayer: function () {
            return (!$scope.isHost);
        },

        isHost: function () {
            return ($scope.isHost);
        },

        isHostController: function () {
            return ($scope.isHost && $scope.showControls);
        },

        isHostDisplay: function () {
            return ($scope.isHost && !$scope.showControls);
        },

        showChooseTeam: function () {
            $scope.screen.mode = 'newteam';
        },

        showWelcomeHost: function () {
            $scope.screen.mode = 'hostplayer';

            $scope.countdown = Counter.start($scope.settings.RoundPauseTime, $scope.startGame);
        },

        showWelcomeTeam: function () {
            $scope.screen.mode = 'welcometeam';

        },

        showRoundSplash: function (round) {
            $scope.logInfo("Display round splash screen for Round " + round.Name);
            
            $scope.rounds.canStart(function() {
                
                $scope.questions.load();
            }, function() {

                $scope.rounds.next();
            }, function() {
                
                $scope.screen.mode = 'newround';
            });

            if ($scope.screen.isHostController()) {
                $scope.screen.mode = 'newround';
            }
        },

        showQuestionSplash: function(question) {

            $scope.logInfo("Displaying question splash screen for Question: " + question.id);

            $scope.options.load(question.id);

            $scope.questions.canStart(function() {
                
                $scope.screen.showQuestionOptions();
            }, function () {

                $scope.questions.next();
            }, function() {

                $scope.screen.mode = 'newquestionsplash';
            });

            if ($scope.screen.isHostController) {
                $scope.screen.mode = 'newquestionsplash';
            }
        },

        showQuestionOptions: function() {
            $scope.logInfo("Display main question screen");

            $scope.screen.mode = 'newquestion';

            $scope.countdown = Counter.start($scope.settings.QuestionTimeLimit, function () {
            	$scope.questions.canComplete(function() {
		      		$scope.questions.current.finish();
		      	}, function () {
		      		$scope.questions.current.restart();
		      	});
            });
        },

        showEndGame: function() {
            $scope.screen.mode = 'endgame';
        }

    }

    Teams.prototype = {
        current: {
            data: undefined,

            check: function() {
                var deferred = $q.defer();

                if (this.current.data != undefined) {

                    return this.getTeam(this.current.data.id);
                }
                else {
                    deferred.reject();
                }

                return deferred.promise;
            }

        },

        setCurrent: function(team) {
            this.current.data = team;
        }
    }

    $scope.teams = new Teams();

    Rounds.prototype = {
        current: {
            data: undefined,

            handle: 0
        },

        sendStartRound: function() {
            return $http.get(this.baseUrl + "/roundprogress/" + this.current.data.id + "/start");
        },

        sendRevertRound: function() {
            return $http.get(this.baseUrl + "/roundprogress/" + this.current.data.id + "/revert")
        },

        sendCompleteRound: function() {

            return $http.get(this.baseUrl + "/roundprogress/" + this.current.data.id + "/complete")
        },

        canStart: function(startedCallback, completedCallback, callback) {
            self = this;
            recurse = function () {
                self.canStart(startedCallback, completedCallback, callback);
            }

            $http.get(this.baseUrl + "/roundprogress/" + this.current.data.id)
                .success(function(response) {
                    if (response.Completed === "1"  && response.Started === "1") {

                        $scope.logInfo("Round is already complete");

                        completedCallback();
                    }
                    else if (response.Started === "1") {

                        $scope.logInfo("Round has started");

                        startedCallback();
                    }
                    else {

                        if (!$scope.showControls) {
                            $timeout(recurse, pollingInterval);
                        }

                        callback();
                    }
                });
        },

        canComplete: function(completedCallback, revertedCallback) {
            self = this;
            recurse = function () {
                self.canComplete(completedCallback, revertedCallback);
            }

            $http.get(this.baseUrl + "/roundprogress/" + this.current.data.id)
                .success(function(response) {
                    if (response.Reverted === "1") {
                        $scope.logInfo("This round has been Reverted");

                        revertedCallback()
                    }
                    else if (response.Started === "1" && response.Completed === "1") {
                        $scope.logInfo("This round has been Completed");

                        completedCallback();
                    }
                    else {
                        
                        $timeout(recurse, pollingInterval);

                        return false;
                    }
                });
        },

        restart: function() {
            $scope.logInfo("Restart this round");

            this.current.handle--;

            this.current.data = this.list[this.current.handle];

            if (this.current.data !== undefined) {
                this.start();
            } else {
                this.load();
            }
        },

        start: function() {
            $scope.logInfo("Starting Rounds sequence");

            this.current.data = this.list[this.current.handle];

            if (this.current.data === undefined) {
                this.next();
                return;
            }

            $scope.screen.showRoundSplash(this.current.data);
        },

        next: function() {
            $scope.logInfo("Go to next round");

            this.current.handle++;

            this.current.data = this.list[this.current.handle];

            if (this.current.data !== undefined) {
                this.start();
            } else {
                $scope.screen.showEndGame();
            }
        }
    }

    $scope.rounds = new Rounds();
    $scope.round = $scope.rounds.current.data;

    Questions.prototype = {

        current: {
            data: undefined,

            handle: 0,

            flags: {},

            resetFlags: function () {
                this.flags.timesUp = false;
                this.flags.madeChoice = false;
            }
        },

        sendStartQuestion: function() {
            return $http.get(this.baseUrl + "/questionprogress/" + this.current.data.id + "/start")
        },

        sendRevertQuestion: function() {
            $http.get(this.baseUrl + "/questionprogress/" + this.current.data.id + "/revert");
        },

        sendCompleteQuestion: function() {

            return $http.get(this.baseUrl + "/questionprogress/" + this.current.data.id + "/complete")
        },

        canStart: function(startedCallback, completedCallback, callback) {
            self = this;
            recurse = function () {
                self.canStart(startedCallback, completedCallback, callback);
            }

            $http.get(this.baseUrl + "/questionprogress/" + this.current.data.id)
                .success(function(response) {
                    if (response.Completed === "1"  && response.Started === "1") {
                        $scope.logInfo("Question is already complete");

                        completedCallback();
                    }
                    else if (response.Started === "1") {
                        $scope.logInfo("Question started");

                        startedCallback();
                    }
                    else {

                        if (!$scope.showControls) {
                            $timeout(recurse, pollingInterval);
                        }

                        callback();
                    }
                });
        },

        canComplete: function(completedCallback, revertedCallback) {
            self = this;
            recurse = function () {
                self.canComplete(completedCallback, revertedCallback);
            }

            $http.get(this.baseUrl + "/questionprogress/" + this.current.data.id)
                .success(function(response) {
                    if (response.Reverted === "1") {
                        $scope.logInfo("This question has been reverted");

                        revertedCallback()
                    }
                    else if (response.Started === "1" && response.Completed === "1") {
                        $scope.logInfo("This question has been completed");

                        completedCallback();
                    }
                    else {
                        
                        $timeout(recurse, pollingInterval);
                    }
                });
        },

        finish: function() {
            $scope.logInfo("Finish the question");

            if (this.current.flags.madeChoice === false && !$scope.isHost) {
                $scope.options.sendNoChoice($scope.team.id, this.current.data.id)
                    .success(function(response) {
                        $scope.logInfo("Empty choice logged");
                    });
            }

            $scope.options.clear();
            this.current.resetFlags();

            this.next();
        },

        restart: function() {
            $scope.logInfo("Go to last question");

            this.current.handle--;

            this.current.data = this.list[this.current.handle];

            if (question !== undefined) {
                this.start();
            } else {
                $scope.rounds.current.restart();
            }
        },

        start: function() {
            $scope.logInfo("Start Questions sequence");

            this.current.data = this.list[this.current.handle];

            if (this.current.data === undefined) {
                this.next();
                return;
            }

            $scope.screen.showQuestionSplash(this.current.data);
        },

        next: function() {
            $scope.logInfo("Go to next question");

            this.current.handle++;

            this.current.data = this.list[this.current.handle];

            if (this.current.data === undefined) {
                $scope.rounds.next();
            } else {
                this.start();
            }
        }
    }

    $scope.questions = new Questions();
    $scope.question = $scope.questions.current.data;

    Options.prototype = {
        hiddenList: [],

        clear: function() {
            this.list = [];
        },

        hideAllBut: function(option) {
            this.hiddenList = this.list;
            this.list = [option];
        },

        showAll: function() {
            this.list = this.hiddenList;
        },
        
        sendChoice: function(teamId, optionId) {
            return httpPost.send(this.baseUrl + "/choices/add",
            {
                teamId: teamId,
                optionId: optionId
            });
        },

        sendNoChoice: function(teamId, questionId) {
          
            return httpPost.send(this.baseUrl + "/choices/addempty", {
                    teamId: teamId,
                    questionId: questionId
                });
        }
    }

    $scope.options = Options;

    $scope.hostControls = {
        startRoundButton: function() {
            $scope.logInfo("Host has started the Round");

            $scope.rounds.sendStartRound()
                .success(function(response) {
                    $scope.logInfo("Tell server we have started the round");

                    $scope.questions.load()
                        .then(function() {
                            if ($scope.questions.list.length > 0) {
                                $scope.questions.start();
                            } else {
                                $scope.rounds.next();
                            }
                        });
                });
        },

        nextRoundButton: function() {
            if ($scope.isHost) {
                $scope.sendCompleteRound();
            }
        },

        completeRoundButton: function() {
            $scope.logInfo("Host has completed this round");

            $scope.rounds.sendCompleteRound()
                .success(function(response) {

                    $scope.rounds.next();
                });
        },

        lastRoundButton: function() {
            $scope.logInfo("Revert round: " + $scope.rounds.current.data.id);

            $scope.rounds.sendRevertRound()
                .success(function(response) {
                    $scope.rounds.restart();
                });
        },

        startQuestionButton: function() {
            $scope.logInfo("Host has started the question");

            $scope.questions.sendStartQuestion()
                .success(function(response) {
                    $scope.screen.showQuestionOptions();
                });
        },

        nextQuestionButton:  function() {
            if ($scope.isHost) {
                $scope.sendCompleteQuestion();
            }
        },

        completeQuestionButton: function() {
          $scope.logInfo("Host has completed this question");

          $scope.questions.sendCompleteQuestion()
            .success(function(response) {
                $scope.questions.next();
            });
        },

        lastQuestionButton: function() {
            $scope.logInfo("Revert question: " + $scope.questions.current.data.id);

            $scope.questions.sendRevertQuestion()
                .success(function(response) {
                    $scope.questions.restart()
                });
        }
    }

    $scope.playerControls = {
        makeChoice: function(option) {

            if ($scope.isHost || $scope.questions.current.flags.timesUp) {
                return;
            }

            $scope.logInfo("Player has made a choice");

            $scope.options.hideAllBut(option);

            $scope.questions.current.flags.madeChoice = true;

            if ($scope.options.list.length == 1) {
                choicePauseTimeMs = $scope.settings.ChoicePauseTime * 1000;

                $timeout(function() {
                    $scope.opions.showAll();
                }, choicePauseTimeMs);
            }

            $scope.options.sendChoice($scope.team.id, option.id)
                .success(function(response) {
                    $scope.logInfo("Players choice logged");
                });;
        }
    }

    $scope.startGame = function() {
        $scope.logInfo("Starting game");

        $scope.rounds.load()
            .then(function() {

                if ($scope.rounds.list.length > 0) {
                    $scope.logInfo("Rounds data successfully loaded");

                    $scope.rounds.start();
                }
            });
    }

    $scope.setTeam = function() {
        if (typeof $scope.team == 'string') {
            $scope.team = JSON.parse($scope.team);
        }

        $scope.storage.team = $scope.team;

        $scope.startGame();
    }

    $scope.welcome = function() {
        if ($scope.isHost) {
            // For the host, show welcome screen
            $scope.screen.showWelcomeHost();
            return;
        }
        else if ($scope.storage.team !== undefined) {
            // Get team from localStorage
            _team = (typeof $scope.storage.team == 'string')
                ? JSON.parse($scope.storage.team)
                : $scope.storage.team;

            $scope.teams.setCurrent(_team);

            // Check team still exists server side
            if ($scope.teams.current.data.id !== undefined) {
                $scope.teams.current.check()
                    .then(function(response) {
                        if (response.id !== undefined) {
                            $scope.screen.showWelcomeTeam();
                        } else {
                            $scope.screen.showChooseTeam();
                        }
                    });
                return;
            }
        }

        $scope.screen.showChooseTeam();
    }


    $scope.init = function() {

        if ($scope.screen.isHostDisplay()) {
            $("#nav-menu").hide();
        }

        Settings.load()
            .then(function() {
                $scope.settings = Settings.get();

                return $scope.teams.load();
            })
            .then(function() {
                $scope.welcome();
            });
    }

    $scope.init();
});
{% endblock %}
